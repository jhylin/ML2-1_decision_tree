---
title: "Tree models in ChEMBL data"
subtitle: "ML series 2.1 - decision tree - data pre-processing (part 2)"
author: Jennifer HY Lin
date: '2023-9-5'
draft: true
categories: 
    - Machine learning projects
    - Pandas
    - ChEMBL database
jupyter: python3
format: html
bibliography: references.bib
---

##### **Data source**

The data used in part 2 of data pre-processing was extracted from ChEMBL database by using ChEMBL webresource client in Python. The details of all the steps taken to reach the final .csv file could be seen in this earlier *post*. Since data preparation and cleaning was a well-known process that would take up a lot of time before doing anything significant on the data, I've splitted this process into two posts to ensure reasonable reading time for each.

```{python}
# Import all libraries used
import pandas as pd
import math
import datamol as dm
```

<br>

##### **Re-importing saved data**

Re-imported the partly pre-processed dtree_df from the earlier post.

```{python}
dtree_df = pd.read_csv("ache_chembl.csv")
dtree_df.head()
```

Noticed there was an extra index column, likely inherited from how the .csv file was saved, which was subsequently removed.

```{python}
dtree_df = dtree_df.drop("Unnamed: 0", axis = 1)
dtree_df.head()
```

The distribution of Ki values were shown below via a simple statistical summary.

```{python}
dtree_df.describe()
```

From the above quick statistical summary and also the code below to find the minimum Ki value, it confirmed that there were no zero Ki values recorded.

```{python}
dtree_df["Ki"].min()
```

Now we could convert the Ki values to pKi values, which were the negative logs of Ki in molar units (a [PubChem example](https://pubchem.ncbi.nlm.nih.gov/bioassay/213088) might help to explain it a little further). The key to understand pKi here was to treat pKi similarly to how we would normally understand pH for our acids and bases. The formula to convert Ki to pKi for nanomolar (nM) units was: 

$$
\text{pKi} = 9 - log _{10}(Ki)
$$

Set up a small function to do the conversion.

```{python}
def calc_pKi(Ki):
    pKi_value = 9 - math.log10(Ki)
    return pKi_value
```

Applying the calc_pKi function to convert all rows of the compound dataset for the "Ki" column.

```{python}
# Create a new column for pKi
# Apply calc_pKi function to the data in Ki column
dtree_df["pKi"] = dtree_df.apply(lambda x: calc_pKi(x.Ki), axis = 1)
```

The dataframe would now look like this, with a new pKi column.

```{python}
dtree_df.head()
```

However, for a decision tree model, a few more molecular descriptors were probably needed rather than only Ki or pKi and SMILES. One way to do this could be through computations based on canonical SMILES of compounds by using RDKit to add some molecular descriptors.

Before doing this, a compound sanitisation step should be done before starting any calculations, as this might rule out some compounds with questionable chemical validities. RDKit or Datamol (a Python wrapper library built based on RDKit) was used in this process.

Also adding a quick step here to convert the data types of "smiles" and "data_validity_comment" columns to string first (in case of running into problems later).

```{python}
dtree_df = dtree_df.astype({"smiles": "string", "data_validity_comment": "string"})
dtree_df.dtypes
```

Also, before jumping straight to compound sanitisation, I remembered that I needed to check the "data_validity_comment" column.

```{python}
dtree_df["data_validity_comment"].unique()
```

There were 3 different types of data validity comments found, which were "NaN", "Outside typical range" and "Potential transcirption error". So, this meant compounds with comments other than "NaN" would need to be addressed first.

```{python}
# Find out number of compounds with "outside typical range" as data validity comment
dtree_df_err = dtree_df[dtree_df["data_validity_comment"] == "Outside typical range"]
print(dtree_df_err.shape)
dtree_df_err.head()
```

There were a total of 58 compounds with Ki outside typical range.

```{python}
# Find out number of compounds with "potential transcription error" as data validity comment
dtree_df[dtree_df["data_validity_comment"] == "Potential transcription error"]
```

There was one compound with potential transcription errors for Ki value.

These compounds with questionable Ki values were removed, as they could be potential sources of errors for ML models later on (error trickling effect). One of the ways I thought of doing was to fill the empty cells within the "data_validity_comment" column first, so it would be easier to filter them out.

```{python}
# Fill "NaN" entries with an actual name e.g. zero
dtree_df = dtree_df.fillna("none")
dtree_df.head(10)
```

Filtered out only the compounds with nil data validity comments.

```{python}
#dtree_df["data_validity_comment"].unique()
dtree_df = dtree_df[dtree_df["data_validity_comment"] == "none"]
```

Checking the dtree_df dataframe again and also whether if only the compounds with "none" labelled for "data_validity_comment" column were kept (and other two types were removed).

```{python}
print(dtree_df.shape)
dtree_df["data_validity_comment"].unique()
```

<br>

#### **Compound sanitisation**

I've found the [pre-processing molecules tutorial](https://docs.datamol.io/stable/tutorials/Preprocessing.html) and its reference links provided by Datamol in the webpage to be very informative. Each steps of fix_mol(), sanitize_mol() and standardize_mol() were explained in the link provided above. I guess the key was to select pre-processing options required to fit the purpose of the ML models being built later on, and more experiences in doing this would also help to improve the compound pre-processing step.

```{python}
# _preprocess function to sanitise compounds - adapted from datamol.io

smiles_column = "smiles"

dm.disable_rdkit_log()

def _preprocess(row):
    # Convert each compound to a RDKit molecule in the smiles column
    mol = dm.to_mol(row[smiles_column], ordered=True)
    # Fix common errors in the molecules
    mol = dm.fix_mol(mol)
    # Sanitise the molecules 
    mol = dm.sanitize_mol(mol, sanifix=True, charge_neutral=False)
    # Standardise the molecules
    mol = dm.standardize_mol(
        mol,
        # Switch on to disconnect metal ions
        disconnect_metals=True,
        normalize=True,
        reionize=True,
        # Switch on "uncharge" to neutralise charges
        uncharge=True,
        # Taking care of stereochemistries of compounds
        stereo=True,
    )

    # Added a new column below for RDKit molecules
    row["rdkit_mol"] = dm.to_mol(mol)
    row["standard_smiles"] = dm.standardize_smiles(dm.to_smiles(mol))
    row["selfies"] = dm.to_selfies(mol)
    row["inchi"] = dm.to_inchi(mol)
    row["inchikey"] = dm.to_inchikey(mol)
    return row
```

Then the compound sanitisation function was applied to the dtree_df.

```{python}
dtree_san_df = dtree_df.apply(_preprocess, axis = 1)
dtree_san_df.head()
```

Please note if the dataset required for sanitisation is large, Datamol has suggested using their example code to add parallelisation as shown below.

``` {{python}}
# Code adapted from: https://docs.datamol.io/stable/tutorials/Preprocessing.html#references
data_clean = dm.parallelized(
    _preprocess, 
    data.iterrows(), 
    arg_type="args", 
    progress=True, 
    total=len(data)
    )
data_clean = pd.DataFrame(data_clean)
```

```{python}
dtree_san_df.shape
```

In this case, I tried using the preprocessing function without adding the parallelisation, the whole sanitisation process wasn't very long (since I had a small dataset), and was done within a minute or so.

<br>

#### **Detect outliers**

Plotting a histogram to see the distribution of pKi values first.

```{python}
dtree_san_df.hist(column = "pKi")
```

I read a bit about Dixon's Q test and realised that there were a few required assumptions prior to using this test, and the current dataset used here (dtree_san_df) might not fit the requirements, which were:

-   normally distributed data
-   a small sample size e.g. between 3 and 10, which was originally stated in this paper [@dean1951].

So I've decided that rather than showing Python code for Dixon's Q test myself, I'd attach a few examples from others instead, [Q test from Plotly](https://plotly.com/python/v3/outlier-test/) and also [Dixon's Q test for outlier identification -- a questionable practice](https://sebastianraschka.com/Articles/2014_dixon_test.html), since this dataset here wasn't quite normally distributed as shown from the histogram plotted above.

```{python}
dtree_san_df.boxplot(column = "pKi")

# the boxplot version below shows a blank background
# rather than above version with horizontal grid lines
#dtree_san_df.plot.box(column = "pKi")
```

I also used Pandas' built-in boxplot in addition to the histogram to show the possible outliers within the pKi values. Clearly, the outliers for pKi values appeared to be above 10. I've also decided not to completely remove these outliers due to the dataset itself being not in a Gaussian distribution (which meant they might not be true outliers).

<br>

#### **Molecular descriptors**

Datamol's molecular descriptors code - check documentations

```{python}
dm.descriptors.batch_compute_many_descriptors()
```
